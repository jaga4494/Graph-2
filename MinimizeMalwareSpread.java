// TC: O(n2) inside dfs we go over connected nodes of a node.
// SC O(n)

// 1->2*->4->5->7*->8  3->9*->6  10->11* Here ans is 9. as removing malware from it can save 3 nodes.

class Solution {
    int color = 0;
    int[] colors;
    public int minMalwareSpread(int[][] graph, int[] initial) {

        if (graph == null || graph.length == 0) {
            return -1;
        }

        int n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);

        for (int i = 0; i < n; ++i) {
            if (colors[i] == -1) {
                dfs(graph, i);
                color++;
            }
        }
        int groups[] = new int[color];

        for (int i = 0; i < n; ++i) {
            groups[colors[i]]++;
        }

        int[] infected = new int[color];

        for (int i = 0; i < initial.length; ++i) {
            int infectedNode = initial[i];
            int groupNumber = colors[infectedNode];
            infected[groupNumber]++;
        }

        int ans = -1;
        for (int i = 0; i < initial.length; ++i) {
            int infectedNode = initial[i];
            int groupNumber = colors[infectedNode];
            if(infected[groupNumber] == 1) { // if only one is infected in a group, we can save others.
                if (ans == -1) {
                    ans = infectedNode;
                } else if (groups[groupNumber] > groups[colors[ans]]) {
                     ans = infectedNode;
                } else if (groups[groupNumber] == groups[colors[ans]] && ans > infectedNode) {
                    ans = infectedNode;
                }
                
            }
        }

        if (ans == -1) { // if ans not found, return the min amaong the initial array
            int min = Integer.MAX_VALUE;
            for (int i = 0; i < initial.length; ++i) {
                min = Math.min(min, initial[i]);
            }
            return min;
        }
        // else return the found value
        return ans;
        
    }

    private void dfs(int[][] graph, int index) {

        if (colors[index] != -1) {
            return;
        }

        colors[index] = color;
        for (int j = 0; j < graph.length; ++j) {
            if (graph[index][j] == 1) {
                dfs(graph, j);
            }
        }

    }

}